## I store geneset db info in a data.table that holds index vectors that are
## directly usable by the limma GSEA methods
##
## The code here facilitates the creatino of these gsea data.tables from
## MSigDB objects, as well as the conversino of these base tables to other
## GSEA related classes.
.valid.prep.x <- c('MArrayLM', 'EList', 'DGEList', 'SummarizedExperiment',
                   'ExpressionSet', 'matrix')
##' Fetch the MSigDB genesets and identify membership.
##'
##' This function works on the MSigDB *.rdata files provied by WEHI here:
##'
##'   http://bioinf.wehi.edu.au/software/MSigDB/
##'
##' @export
##'
##' @param x An object to prep the MSigDB for. We need to extract the
##' entrez IDs from this object such that each element extracted is
##' the entrez id for the row in \code{x}
##' @param geneset A character vector indicating the names of the MSigDB
##' gene setes to use (ie. c1, ..., c7).
##' @param min.geneset.size The minimum size of the geneset required for it
##' to be included in the return value
##' @param species either \code{human} or \code{mouse}
##' @param path The directory to the MSigDB files generated by WEHI
##' @param x2gs A character vector that maps identifiers from \code{x}
##' to the identifiers in \code{geneset} (FWIW the MSigDB genesets use
##' entrez ids)
##' @return A data.table with the prepped genesets. \code{$membership} is the
##' "canonical" \code{index} vector in the limma GSE tests, the other columns
##' are there for some stats mojo.
prepMsigDB <- function(x, geneset, min.geneset.size=5,
                       species=.wehi.msigdb.species,
                       path=getOption('at.msigdb.path', character()),
                       x2gs=NULL) {
  species <- match.arg(species)
  valid.gset <- switch(species,
                       human=paste0('c', 1:7),
                       mouse=paste0('c', 2:7)) ## No c1 for mouse from WEHI
  if (missing(geneset)) {
    geneset <- valid.gset
  }

  if (inherits(x, .valid.prep.x)) {
    x <- as.character(rownames(x))
  }
  if (!is.character(x)) {
    stop("`x` should have been converted to a character vector already")
  }
  x <- sub('GeneID:', '', x)

  ## Checking path to msigdb objects
  if (!isTRUE(file.info(path)$isdir)) {
    stop("path to MSigDB files is invalid: ", path)
  }

  geneset <- unique(geneset)
  if (length(bad.set <- setdiff(geneset, valid.gset))) {
    stop("Illegal geneset identifiers: ", bad.set)
  }

  msig.files <- local({
    files <- dir(path, species, full.names=TRUE)
    cnames <- sub('_.*', '', sub('.*?_', '', basename(files)))
    if (!setequal(cnames, valid.gset)) {
      stop("Unexpected/incompliete files found in path [", path, "] ")
    }
    setNames(files, cnames)
  })
  msig.files <- msig.files[geneset]

  ## crate a data.frame that has statistics per geneset:
  ## 1. N: size of geneset
  ## 2. n: number of genes in geneset that are in x
  ## 3. This column is a list of logical vectors. Each such vector is as long as
  out <- lapply(names(msig.files), function(grp) {
    fn <- msig.files[[grp]]
    db <- get(load(fn))
    prepGSList(x, db, grp, min.geneset.size=min.geneset.size, x2gs=x2gs)
  })

  out <- rbindlist(out)
  attr(out, 'gene.id') <- x
  out
}

.gs.table <- data.table(group=character(), id=character(), N=integer(),
                        n=integer(), membership=as.list(logical()))

##' @param x Something that indicates order of genes
##' @param genest list of genesets. The elements of each list is a character
##' vector indicating the gene ID's in the geneset.
##' @param rm.geneID Remove any GeneID: prefix anywhere
##' @param x2gs A character vector that maps identifiers from \code{x}
##' to the identifiers in \code{geneset} (FWIW the MSigDB genesets use
##' entrez ids)
prepGSList <- function(x, geneset, group='gs', min.geneset.size=5,
                       rm.geneID=TRUE, x2gs=NULL) {
  if (inherits(x, .valid.prep.x)) {
    x <- as.character(rownames(x))
  }
  if (is.factor(x)) {
    x <- as.character(x)
  }
  if (!is.character(x)) {
    stop("`x` should have been converted to a character vector already")
  }
  if (rm.geneID) {
    x <- sub('GeneID:', '', x)
  }

  if (is.character(geneset)) {
    geneset <- list(gs1=geneset)
  }
  if (!class(geneset)[1L] == 'list') {
    stop("list expected for `geneset`")
  }

  if (is.null(names(geneset))) {
    names(geneset) <- paste0('gs.', seq(geneset))
  }

  if (is.character(x2gs)) {
    xo <- x
    xmap <- x2gs[x]
    x <- ifelse(is.na(xmap), xo, xmap)
    names(x) <- NULL
  }

  ## keep <- sapply(geneset, function(gs) length(gs) >= min.geneset.size)
  ## geneset <- geneset[keep]
  ## if (length(geneset) == 0) {
  ##   return(.gs.table)
  ## }

  gs.size <- sapply(geneset, length)
  membership <- lapply(geneset, function(ids) {
    if (rm.geneID) {
      ids <- sub('GeneID:', '', ids)
    }
    x %in% ids
  })
  n <- sapply(membership, sum)
  gs <- data.table(group=group, id=names(geneset), N=gs.size, n=n,
                   membership=membership)
  attr(gs, 'gene.id') <- x

  too.small <- gs$n == 0 | gs$n < min.geneset.size
  if (sum(too.small)) {
    warning("There are ", sum(too.small), " genesets in group `", group, "` ",
            "that have fewer genes in `x` than min.gneset.size ",
            sprintf("(=%d)", min.geneset.size),
            immediate.=TRUE)
    gs <- gs[!too.small]
  }

  gs
}

## Helper function, check if `x` is a table like the one produced by prepMsigDB
is.gs.table <- function(x) {
  if (!is.data.table(x))  {
    return(FALSE)
  }

  valid.cols <- sapply(names(.gs.table), function(col) {
    dat <- x[[col]]
    clazz <- class(.gs.table[[col]])[1L]
    !is.null(dat) && is(dat, clazz)
  })
  if (!all(valid.cols)) {
    return(FALSE)
  }

  is.logical.idx <- sapply(x$membership, is, 'logical')
  if (!all(is.logical.idx)) {
    return(FALSE)
  }
  lens <- sapply(x$membership, length)
  if (length(unique(lens)) != 1) {
    return(FALSE)
  }
  if (!is.character(attr(x, 'gene.id'))) {
    return(FALSE)
  }

  TRUE
}

gs.table2GeneSetCollection <- function(x) {
  if (!require(GSEABase)) {
    stop("GSEAbase required to create a GeneSetCollection")
  }
  if (!is.gs.table(x)) {
    stop("A gs.table of the form created by `prepGSList` is required")
  }

  x.gids <- attr(x, 'gene.id')

  gs.collection <- lapply(1:nrow(x), function(idx) {
    gids <- unique(x.gids[unlist(x$membership[[idx]])])
    sid <- x$id[idx]
    GeneSet(geneIds=gids, setName=sid, setIdentifier=sid)
  })

  GeneSetCollection(gs.collection)
}
